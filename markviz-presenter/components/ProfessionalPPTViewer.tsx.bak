import React, { useState, useEffect, useRef } from 'react';
import { ChevronLeft, ChevronRight, Maximize2, Minimize2, Download, AlertCircle } from 'lucide-react';

interface ProfessionalPPTViewerProps {
  src: string;
  name: string;
}

interface Slide {
  elements: any[];
  width?: number;
  height?: number;
}

interface PPTXData {
  slides: Slide[];
  pageSize: {
    width: { value: number };
    height: { value: number };
  };
}

export const ProfessionalPPTViewer: React.FC<ProfessionalPPTViewerProps> = ({ src, name }) => {
  const [pptxData, setPptxData] = useState<PPTXData | null>(null);
  const [currentSlide, setCurrentSlide] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // åŠ è½½PPTXæ–‡ä»¶
  useEffect(() => {
    const loadPPTX = async () => {
      try {
        setLoading(true);
        setError(null);

        console.log('ğŸ”„ ä½¿ç”¨ä¸“ä¸šPPTè§£æå™¨åŠ è½½æ–‡ä»¶...');
        const response = await fetch(src);
        if (!response.ok) throw new Error('æ— æ³•åŠ è½½PPTæ–‡ä»¶');

        const arrayBuffer = await response.arrayBuffer();

        // å°†ArrayBufferè½¬æ¢ä¸ºFileå¯¹è±¡
        const blob = new Blob([arrayBuffer], { type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation' });
        const file = new File([blob], name || 'presentation.pptx', { type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation' });

        // åŠ¨æ€å¯¼å…¥pptx-parseråº“
        const { parse } = await import('pptx-parser');

        // ä½¿ç”¨ä¸“ä¸šPPTè§£æå™¨
        const parsedData = await parse(file, { flattenGroup: true });
        console.log('âœ… PPTè§£ææˆåŠŸï¼Œå¹»ç¯ç‰‡æ•°é‡:', parsedData.slides.length);

        if (!parsedData.slides || parsedData.slides.length === 0) {
          throw new Error('PPTæ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°å¹»ç¯ç‰‡å†…å®¹');
        }

        setPptxData(parsedData);
        setCurrentSlide(0);

      } catch (err: any) {
        console.error('PPTåŠ è½½é”™è¯¯:', err);

        let errorMessage = err.message || 'PPTæ–‡ä»¶è§£æå¤±è´¥';

        // æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’Œå»ºè®®
        if (errorMessage.includes('fetch')) {
          errorMessage += '\n\nå»ºè®®ï¼š\nâ€¢ æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®\nâ€¢ ç¡®è®¤æ–‡ä»¶å­˜åœ¨ä¸”å¯è®¿é—®';
        } else {
          errorMessage += '\n\nå»ºè®®ï¼š\nâ€¢ ç¡®ä¿æ–‡ä»¶æ˜¯æœ‰æ•ˆçš„PPTXæ ¼å¼\nâ€¢ å°è¯•é‡æ–°å¯¼å‡ºä¸º.pptxæ ¼å¼\nâ€¢ æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æŸå';
        }

        setError(errorMessage);
      } finally {
        setLoading(false);
      }
    };

    if (src) {
      loadPPTX();
    }
  }, [src]);

  // æ¸²æŸ“å¹»ç¯ç‰‡åˆ°Canvas
  useEffect(() => {
    if (pptxData && pptxData.slides && currentSlide < pptxData.slides.length && canvasRef.current) {
      renderSlideToCanvas(pptxData.slides[currentSlide], canvasRef.current);
    }
  }, [pptxData, currentSlide]);

  // æ¸²æŸ“å¹»ç¯ç‰‡åˆ°Canvas
  const renderSlideToCanvas = (slide: Slide, canvas: HTMLCanvasElement) => {
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // ä½¿ç”¨pptxDataä¸­çš„é¡µé¢å°ºå¯¸ï¼Œè½¬æ¢ä¸ºåƒç´ 
    const scaleFactor = 1; // PPTXä¸­çš„å•ä½é€šå¸¸æ˜¯EMUï¼Œéœ€è¦è½¬æ¢
    const width = pptxData?.pageSize?.width?.value ? pptxData.pageSize.width.value / 9525 : 960;
    const height = pptxData?.pageSize?.height?.value ? pptxData.pageSize.height.value / 9525 : 540;

    // è®¾ç½®Canvaså°ºå¯¸
    canvas.width = width;
    canvas.height = height;

    // æ¸…ç©ºç”»å¸ƒ
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // æ¸²æŸ“å¹»ç¯ç‰‡å…ƒç´ 
    if (slide && slide.elements && slide.elements.length > 0) {
      slide.elements.forEach((element, index) => {
        try {
          renderElement(ctx, element, canvas.width, canvas.height);
        } catch (elementError) {
          console.warn(`æ¸²æŸ“å…ƒç´  ${index} å¤±è´¥:`, elementError);
        }
      });
    } else {
      // å¦‚æœæ²¡æœ‰å…ƒç´ ï¼Œæ˜¾ç¤ºå ä½æ–‡æœ¬
      ctx.fillStyle = '#666666';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`å¹»ç¯ç‰‡ ${currentSlide + 1}`, canvas.width / 2, canvas.height / 2);
    }
  };

  // æ¸²æŸ“å•ä¸ªå…ƒç´ 
  const renderElement = (ctx: CanvasRenderingContext2D, element: any, canvasWidth: number, canvasHeight: number) => {
    const { type, x, y, width, height, text, style = {} } = element;

    ctx.save();

    // è½¬æ¢åæ ‡ï¼ˆPPTXåæ ‡é€šå¸¸æ˜¯ä»¥EMUsä¸ºå•ä½ï¼‰
    const px = (x || 0) / 9525; // è½¬æ¢ä¸ºåƒç´ 
    const py = (y || 0) / 9525;
    const pw = (width || 0) / 9525 || 200;
    const ph = (height || 0) / 9525 || 50;

    switch (type) {
      case 'text':
      case 'paragraph':
        // è®¾ç½®æ–‡æœ¬æ ·å¼
        ctx.fillStyle = style.color || '#000000';
        ctx.font = `${style.bold ? 'bold' : 'normal'} ${style.italic ? 'italic' : 'normal'} ${style.fontSize || 18}px ${style.fontFamily || 'Arial'}`;
        ctx.textAlign = style.textAlign || 'left';
        ctx.textBaseline = 'top';

        // å¤„ç†å¤šè¡Œæ–‡æœ¬
        if (Array.isArray(text)) {
          text.forEach((line: string, index: number) => {
            ctx.fillText(line || '', px, py + (index * (style.fontSize || 18)));
          });
        } else {
          ctx.fillText(text || '', px, py);
        }
        break;

      case 'shape':
        // ç»˜åˆ¶å½¢çŠ¶
        ctx.fillStyle = style.fill || '#FFFFFF';
        ctx.strokeStyle = style.stroke || '#000000';
        ctx.lineWidth = style.strokeWidth || 1;

        // æ ¹æ®å½¢çŠ¶ç±»å‹ç»˜åˆ¶
        switch (element.shapeType) {
          case 'rect':
          case 'rectangle':
            ctx.fillRect(px, py, pw, ph);
            if (style.stroke) {
              ctx.strokeRect(px, py, pw, ph);
            }
            break;

          case 'circle':
          case 'ellipse':
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph/2, pw/2, ph/2, 0, 0, 2 * Math.PI);
            ctx.fill();
            if (style.stroke) {
              ctx.stroke();
            }
            break;

          default:
            // é»˜è®¤çŸ©å½¢
            ctx.fillRect(px, py, pw, ph);
            break;
        }

        // å¦‚æœæœ‰æ–‡æœ¬ï¼Œåœ¨å½¢çŠ¶ä¸Šç»˜åˆ¶æ–‡æœ¬
        if (text) {
          ctx.fillStyle = style.color || '#000000';
          ctx.font = `${style.fontSize || 14}px ${style.fontFamily || 'Arial'}`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(text, px + pw/2, py + ph/2);
        }
        break;

      case 'image':
        // å¤„ç†å›¾ç‰‡ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦åŠ è½½å›¾ç‰‡ï¼‰
        if (element.src) {
          ctx.fillStyle = '#E0E0E0';
          ctx.fillRect(px, py, pw, ph);
          ctx.fillStyle = '#666666';
          ctx.font = '14px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('å›¾ç‰‡', px + pw/2, py + ph/2);
        }
        break;

      default:
        console.log('æœªçŸ¥å…ƒç´ ç±»å‹:', type);
        break;
    }

    ctx.restore();
  };

  // å¯¼èˆªåŠŸèƒ½
  const goToSlide = (index: number) => {
    if (pptxData && pptxData.slides && index >= 0 && index < pptxData.slides.length) {
      setCurrentSlide(index);
    }
  };

  const toggleFullscreen = () => {
    if (!containerRef.current) return;

    if (!isFullscreen) {
      containerRef.current.requestFullscreen?.();
    } else {
      document.exitFullscreen?.();
    }
    setIsFullscreen(!isFullscreen);
  };

  // é”®ç›˜å¯¼èˆª
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      switch (e.key) {
        case 'ArrowLeft':
          goToSlide(currentSlide - 1);
          break;
        case 'ArrowRight':
        case ' ':
          goToSlide(currentSlide + 1);
          break;
        case 'Escape':
          if (isFullscreen) {
            toggleFullscreen();
          }
          break;
        case 'f':
        case 'F':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            toggleFullscreen();
          }
          break;
      }
    };

    if (pptxData && pptxData.slides && pptxData.slides.length > 0) {
      window.addEventListener('keydown', handleKeyPress);
      return () => window.removeEventListener('keydown', handleKeyPress);
    }
  }, [currentSlide, pptxData?.slides?.length, isFullscreen]);

  return (
    <div
      ref={containerRef}
      className="ppt-viewer my-4 rounded-lg overflow-hidden border"
      style={{ borderColor: 'var(--border)' }}
    >
      {/* å¤´éƒ¨å·¥å…·æ  */}
      <div
        className="flex items-center justify-between px-4 py-3"
        style={{ backgroundColor: 'var(--bg-secondary)' }}
      >
        <div className="flex items-center gap-2">
          <span className="font-medium" style={{ color: 'var(--text-primary)' }}>
            {name}
          </span>
          {pptxData && pptxData.slides && pptxData.slides.length > 0 && (
            <span className="text-sm ml-2" style={{ color: 'var(--text-muted)' }}>
              ({currentSlide + 1} / {pptxData.slides.length})
            </span>
          )}
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={toggleFullscreen}
            className="p-2 rounded transition-colors hover:bg-opacity-80"
            style={{ color: 'var(--text-secondary)' }}
            title={isFullscreen ? 'é€€å‡ºå…¨å±' : 'å…¨å±'}
          >
            {isFullscreen ? <Minimize2 size={18} /> : <Maximize2 size={18} />}
          </button>
          <a
            href={src}
            download={name}
            className="px-3 py-1.5 rounded text-sm font-medium transition-colors flex items-center gap-1"
            style={{
              backgroundColor: 'var(--accent)',
              color: 'white'
            }}
            title="ä¸‹è½½PPT"
          >
            <Download size={14} />
            ä¸‹è½½
          </a>
        </div>
      </div>

      {/* Canvasæ¸²æŸ“åŒºåŸŸ */}
      <div
        className={`relative w-full flex items-center justify-center ${isFullscreen ? 'flex-1' : ''}`}
        style={{
          height: isFullscreen ? 'calc(100vh - 120px)' : '540px',
          backgroundColor: 'var(--bg-tertiary)'
        }}
      >
        {loading ? (
          <div className="flex flex-col items-center gap-4" style={{ color: 'var(--text-secondary)' }}>
            <div className="animate-spin rounded-full h-12 w-12 border-4 border-t-transparent" style={{ borderColor: 'var(--accent)', borderTopColor: 'transparent' }}></div>
            <p>æ­£åœ¨è§£æPPT...</p>
          </div>
        ) : error ? (
          <div className="flex flex-col items-center gap-4 px-8 text-center max-w-2xl" style={{ color: 'var(--text-secondary)' }}>
            <AlertCircle size={48} style={{ color: 'var(--warning)', opacity: 0.7 }} />
            <div className="text-sm leading-relaxed">
              {error.split('\n').map((line, index) => (
                <div key={index} className={index === 0 ? 'font-medium mb-2' : 'text-xs mt-1'}>
                  {line.startsWith('â€¢') ? (
                    <span className="block text-left pl-4">â€¢ {line.slice(1).trim()}</span>
                  ) : (
                    line
                  )}
                </div>
              ))}
            </div>
          </div>
        ) : pptxData && pptxData.slides && pptxData.slides.length > 0 ? (
          <>
            <canvas
              ref={canvasRef}
              className="shadow-lg"
              style={{
                maxWidth: '100%',
                maxHeight: '100%',
                backgroundColor: 'white'
              }}
            />

            {/* å¯¼èˆªæŒ‰é’® */}
            {currentSlide > 0 && (
              <button
                onClick={() => goToSlide(currentSlide - 1)}
                className="absolute left-4 top-1/2 -translate-y-1/2 p-3 rounded-full transition-colors hover:scale-110 shadow-lg"
                style={{
                  backgroundColor: 'var(--bg-secondary)',
                  color: 'var(--text-primary)'
                }}
                title="ä¸Šä¸€å¼  (â†)"
              >
                <ChevronLeft size={24} />
              </button>
            )}
            {pptxData && currentSlide < pptxData.slides.length - 1 && (
              <button
                onClick={() => goToSlide(currentSlide + 1)}
                className="absolute right-4 top-1/2 -translate-y-1/2 p-3 rounded-full transition-colors hover:scale-110 shadow-lg"
                style={{
                  backgroundColor: 'var(--bg-secondary)',
                  color: 'var(--text-primary)'
                }}
                title="ä¸‹ä¸€å¼  (â†’)"
              >
                <ChevronRight size={24} />
              </button>
            )}

            {/* å¹»ç¯ç‰‡æŒ‡ç¤ºå™¨ */}
            <div className="absolute bottom-4 left-1/2 -translate-x-1/2 flex gap-2">
              {pptxData.slides.map((_, index) => (
                <button
                  key={index}
                  onClick={() => goToSlide(index)}
                  className={`w-2 h-2 rounded-full transition-all ${
                    index === currentSlide
                      ? 'w-8 opacity-100'
                      : 'opacity-50 hover:opacity-75'
                  }`}
                  style={{
                    backgroundColor: 'var(--text-secondary)'
                  }}
                  title={`è½¬åˆ°å¹»ç¯ç‰‡ ${index + 1}`}
                />
              ))}
            </div>
          </>
        ) : (
          <div className="text-center" style={{ color: 'var(--text-muted)' }}>
            <p>æ²¡æœ‰æ‰¾åˆ°å¹»ç¯ç‰‡å†…å®¹</p>
          </div>
        )}
      </div>
    </div>
  );
};